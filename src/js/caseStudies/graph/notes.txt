Implementing a regular graph vs managed graph:
 - regular graph 5-6x faster
 - amount of code about equal 162(js) vs 96+58(manager + schema)
 - refactoring for regular graph to support 3d points:
     - requires changes to point, quadraticPoint, bezierPoint class
     - requires addition of type checking behaviour for new arguments
     - minor update of new line function
     - requires update of draw function for 3d

     we see that refactoring is spread around multiple classes for both data and functionality

- refactoring for managed graph to support 3d points:
     - add z coordinate to point schema (1 line)
     - minor update of new line function
     - update draw function for 3d

     data definition is separated from its implementation: only need to change point schema to change data definition.
     when data definition changes we obviously need to update our methods within the data manager. This is however limited to
     functionality that applies to the usage of the data. Type checking, or other behaviour that should apply to ALL data for that matter, does not need to be redefined or added for the new addition of an extra coordinate. We will illustrate this by defining a new Factory and MObject that implements persistence.


Extending the graphManager to be persistent is done in three steps:

Extending MObject:
	the MObject implements a save() and load() function. Load will be called by the data manager, while save is called everytime a record is changed through the intercepted __set() function.
Extending Factory:
	the factory needs to do two things: override the default MObject by setting its MObj field to the class of the new MObject
	and it adds itself to the factory property of the otherInits. The properties stored within other inits will be added to the MObject. This factory can then be used to reconstruct saved objects when they are loaded from localStorage.
Extending data manager:
	the data manager needs to take care of remembering which lines are saved. This is done by creating an array in local storage containing IDs of stored lines. Whenever a new line is added, its id is added to the localStorage.storedLines property. It also provides a getStoredLines function so the "outside world" can know which lines exists. This will be used
	for the line loading interface. Finally, it needs to implement a load function which takes an id, creates a new line, forwards the id it received to the load function of the newly created line, so that it can be filled with the data that was
	stored earlier, and finally it adds the loaded line to the graph.