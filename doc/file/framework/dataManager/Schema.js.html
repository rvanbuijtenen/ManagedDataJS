<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">framework/dataManager/Schema.js | ManagedDataJS</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="An implementation of Managed Data in Javascript using ES6 proxies"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ManagedDataJS"><meta property="twitter:description" content="An implementation of Managed Data in Javascript using ES6 proxies"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/rvanbuijtenen/ManagedDataJS.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#datamanager">dataManager</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/DataManager.js~DataManager.html">DataManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/MObject.js~MObject.html">MObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/MObject.js~MObjectHandler.html">MObjectHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/Schema.js~KlassSchema.html">KlassSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/Schema.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSchema">parseSchema</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#datamanager-fields">dataManager/fields</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~ArrayHandler.html">ArrayHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~ArrayMField.html">ArrayMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~EnumMField.html">EnumMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~OneOfMField.html">OneOfMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~BooleanMField.html">BooleanMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~IntegerMField.html">IntegerMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~MField.html">MField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~MObjectMField.html">MObjectMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~NumberMField.html">NumberMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~StringMField.html">StringMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-MFieldFactory">MFieldFactory</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#mixins">mixins</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Locking">Locking</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Logging">Logging</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Persistence">Persistence</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">framework/dataManager/Schema.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * An instance of KlassSchema describes an MObjects fields, fieldTypes and field relations.
 */
export class KlassSchema {
	/**
	 * A simple constructor that initializes fields and fieldTypes. It takes a string representing
	 * the klass&apos;s name as argument.
	 *
	 * @param {String} klass - A string representing the klass&apos;s name
	 */
	constructor(klass) {
		/**
		 * @type {String} A string representiing the klass&apos;s name
		 */
		this.klass = klass

		/**
		 * @type {Object} An object that maps property keys to field schemas
		 */
		this.fields = {}

		/**
		 * @type{Object} an object that maps property keys to field types
		 */
		this.fieldTypes = {}
	}

	/**
	 * @param {String, Symbol} propKey - The key of the field that we want to set the schema for
	 * @param {Object} field - A parsed JSON schema representing a single property
	 * @param {String} type - The type of the field that we want to set
	 */
	addFieldSchema(propKey, field, type) {
		this.fields[propKey] = field
		this.fieldTypes[propKey] = type
	}

	/**
	 * @param {String, Symbol} propKey - The key of the field that we want to retrieve the schema of
	 * @return {Object} - A parsed JSON schema representing the requested property
	 * @throws {TypeError} - An error is thrown if the requested field does not exist
	 */
	getFieldSchema(propKey) {
		if(this.fields.hasOwnProperty(propKey)) {
			return this.fields[propKey]
		} else {
			throw new TypeError(propKey + &quot; is not defined in schema&quot;)
		}
	}

	/**
	 * @param {String, Symbol} propKey - The key of the field that we want to know if it exists
	 * @return {Boolean} - True if the field exists, false otherwise
	 */
	hasFieldSchema(propKey) {
		if(this.fields.hasOwnProperty(propKey)) {
			return true
		} else {
			return false
		}
	}

	/**
	 * @param {String, Symbol} propKey - The key of the field that we want to retrieve the type of
	 * @return {String} - the type of the requested field
	 * @throws {TypeError} - An error is thrown if the requested field does not exist
	 */
	getFieldType(propKey) {
		if(this.fields.hasOwnProperty(propKey)) {
			return this.fieldTypes[propKey]
		} else {
			throw new TypeError(propKey + &quot; is not defined in schema&quot;)
		}
	}

	/**
	 * @return {String} A string representing this klass&apos;s type
	 */
	getKlass() {
		return this.klass
	}
}

/**
 * Schema is a wrapper that provides an addKlass and a getKlassByName method. These methods are used to manage an
 * object that maps klass names to KlassSchemas. it&apos;s purpose is to group multiple KlassSchemas into a single Schema
 */
export class Schema {
	/**
	 * A simple constructor that initializes the internal klasses property
	 */
	constructor() {
		/**
		 * @type {Object} An object that maps klass names to Klass instances
		 */
		this.klasses = {}
	}

	/**
	 * @param {String} klassName - A string representing the klass name that we want to add
	 * @param {Klass} klass - The klass that we want to add
	 */
	addKlass(klassName, klass) {
		this.klasses[klassName] = klass
	}

	/**
	 * @param {String} klassName - The klass that we want to retrieve
	 * @return {Klass} The klass corresponding with the given klassName
	 * @throws {TypeError} An error is thrown when the given klassName does not exist
	 */ 
	getKlassByName(klassName) {
		if(this.klasses.hasOwnProperty(klassName)) {
			return this.klasses[klassName]
		} else {
			throw new TypeError(&quot;unknown klass: &quot; + klassName)
		}
	}
}

/**
 * @param {Object} schema - A JSON schema
 * @return {Schema} A parsed JSON schema
 */
export function parseSchema(schema) {
	/* Verify that the schema contains the required &apos;name&apos; and &apos;properties&apos; property */
	if(!schema.hasOwnProperty(&quot;name&quot;)) {
		throw new TypeError(&quot;A schema must have a &apos;name&apos; property&quot;)
	}

	if(!schema.hasOwnProperty(&quot;properties&quot;)) {
		throw new TypeError(&quot;A schema must have &apos;properties&apos;&quot;)
	}

	/* Create a new instance of Schema */
	let parsedSchema = new Schema()

	/* Initialize paths: an object that maps a definition path to a klass name. 
	 * the path &apos;#&apos; refers to the main schema.
	 * paths of the form &apos;#/definitions/&lt;klassName&gt;&apos; refers to a definition */
	let paths = {}
	paths[&quot;#&quot;] = schema.name

	let hasDefinitions = false
	/* Parse definitions if there are any */
	if(schema.hasOwnProperty(&quot;definitions&quot;)) {
		for(let definition in schema.definitions) {
			parseDefinitions(schema.definitions, parsedSchema, paths)
		}
	}

	/* Parse the mainKlass */
	let mainKlass = parseKlass(schema, schema.name, paths)
	parsedSchema.addKlass(schema.name, mainKlass)

	parseRelations(schema, parsedSchema, paths)

	return parsedSchema
}

/**
 * @param {Object} definitions - A &apos;definitions&apos; object from a JSON schema
 * @param {Schema} schema - A Schema where parseDefinitions can store parsed klasses
 * @param {Object} paths - An object that maps schema paths to the corresponding klass name
 */
function parseDefinitions(definitions, schema, paths) {
	/* For each definition: map the path of that definition to the definition (klassName) */
	for(let definition in definitions) {
		paths[&quot;#/definitions/&quot; + definition] = definition
	}

	/* For each definition: parse the klass that it describes and add it to the schema */
	for(let definition in definitions) {
		let klass = parseKlass(definitions[definition], definition, paths) 
		schema.addKlass(definition, klass)
	}
}

/**
 * @param {Object} klassSchema - A JSON schema describing the klass
 * @param {String} klassName - The name of this klass
 * @param {Object} paths - An object that maps schema paths to the corresponding klass name
 * @return {Klass} A parsed klass
 */
function parseKlass(klassSchema, klassName, paths) {
	/* Create a new empty Klass */
	let klass = new KlassSchema(klassName)

	/* For each property: parse the property and add it to the Klass */
	for(let property in klassSchema.properties) {
		let prop = klassSchema.properties[property]
		let type = getType(prop)

		klass.addFieldSchema(property, parseProperty(prop, type, paths), type)
	}

	return klass
}

/**
 * @param {Object} schema - A complete (raw) JSON schema
 * @param {Schema} parsedSchema - A Schema object that contains the parsed Klasses to which relations must be added
 * @param {Object} paths - An object that maps a path of the form &quot;#&quot; or &quot;#/definitions/&lt;klassName&gt;&quot; to the corresponding klassName
 */
function parseRelations(schema, parsedSchema, paths) {
	/* parse relations for the main klass */
	if(schema.hasOwnProperty(&quot;relations&quot;)) {
		for(let relation in schema.relations) {
			parseRelation(relation, schema.relations[relation], parsedSchema, schema.name, paths)
		}
	}

	/* parse relations for all other classes defined in &quot;definitions&quot; */
	if(schema.hasOwnProperty(&quot;definitions&quot;)) {
		for(let definition in schema.definitions) {	
			if(schema.definitions[definition].hasOwnProperty(&quot;relations&quot;)) {
				for(let relation in schema.definitions[definition].relations) {
					parseRelation(relation, schema.definitions[definition].relations[relation], parsedSchema, definition, paths)
				}
			}	
		}
	}
}

/**
 * @param {String} relationType - String describing the type of relation. One of [&quot;oneToOne&quot;, &quot;oneToMany&quot;, &quot;manyToMany&quot;]
 * @param {Object} relations - A raw JSON schema for relations.
 * @param {parsedSchema} Schema - An instance of Schema that already contains all basic klass definitions.
 * @param {String} klassName - A string describing the name of the klass that these relations belong to.
 * @param {Object} paths - A javascript object that maps schema paths to klass names.
 * @throws {TypeError} When an invalid relation keyword is found in the schema, an error is thrown.
 */
function parseRelation(relationType, relations, parsedSchema, klassName, paths) {
	let fieldsList = []
	let inversesList = []
	switch(relationType) {
		case &quot;oneToOne&quot;: {
			for(let relation of relations) {
				let {field, inverses} = buildOneToOne(relation, klassName, paths)
				fieldsList.push(field)
				inversesList.push(inverses)
			}
			break;
		}
		case &quot;oneToMany&quot;: {
			for(let relation of relations) {
				let {field, inverses} = buildOneToMany(relation, klassName, paths)
				fieldsList.push(field)
				inversesList.push(inverses)
			}
			break;
		}
		case &quot;manyToMany&quot;: {
			for(let relation of relations) {
				let {field, inverses} = buildManyToMany(relation, klassName, paths)
				fieldsList.push(field)
				inversesList.push(inverses)
			}
			break;
		}
		default: {
			throw new TypeError(relationType + &quot;is not a valid relation type. Please use one of [oneToOne, oneToMany, manyToMany]&quot;)
		}
	}
	for(let field of fieldsList) {
		parsedSchema.klasses[klassName].addFieldSchema(field.key, field.schema, field.type)
	}

	for(let inverses of inversesList) {
		for(let inverseKlass in inverses) {
			parsedSchema.klasses[inverseKlass].addFieldSchema(inverses[inverseKlass].key, inverses[inverseKlass].schema, inverses[inverseKlass].type)
		}
	}
}

/**
 * @param {Object} schema - A raw JSON schema describing a relation
 * @param {Object} paths - A javascript object that maps schema paths to klass names
 * @Throws {TypeError} A TypeError is thrown when the schema contains an incorrect reference
 */
function validateRelationSchema(schema, paths) {
	if(schema.hasOwnProperty(&quot;$ref&quot;)) {
		if(!paths.hasOwnProperty(schema[&quot;$ref&quot;])) {
			throw new TypeError(schema[&quot;$ref&quot;] + &quot; is not a valid schema reference&quot;)
		}
	} else if (schema.hasOwnProperty(&quot;oneOf&quot;)) {
		for(let item of schema.oneOf) {
			if(item.hasOwnProperty(&quot;$ref&quot;)) {
				if(!paths.hasOwnProperty(item[&quot;$ref&quot;])) {
					throw new TypeError(item[&quot;$ref&quot;] + &quot; is not a valid schema reference&quot;)
				}
			} else {
				throw new TypeError(&quot;An item in &apos;oneOf&apos; must have a &apos;$ref&apos; keyword referencing a schema&quot;)
			}
		}
	}
}

/**
 * @param {Object} relation - A single schema describing a relation
 * @param {String} klassName - The klass that this relation belongs to
 * @param {Object} paths - A javascript object that maps schema paths to klass names
 * @return {Object, Object} - buildOneToOne creates the fields required for a one to 
 * one relation. The first object is the field for the klass initiating the relation.
 * The second object contains an inverse field for each other klass involved in the relation.
 */
function buildOneToOne(relation, klassName, paths) {
	validateRelationSchema(relation, paths)

	let field = {}
	let inverses = {}
	if(relation.hasOwnProperty(&quot;$ref&quot;)) {
		let relatedKlass = paths[relation[&quot;$ref&quot;]]
		field.schema = buildObjectField(relatedKlass, relation.referred, &quot;object&quot;)
		field.key = relation.referrer
		field.type = &quot;object&quot;

		inverses[relatedKlass] = {}
		inverses[relatedKlass].schema = buildObjectField(klassName, relation.referrer, &quot;object&quot;)
		inverses[relatedKlass].type = &quot;object&quot;
		inverses[relatedKlass].key = relation.referred
	} else if (relation.hasOwnProperty(&quot;oneOf&quot;)) {
		field = {}
		field.type=&quot;oneOf&quot;
		field.key=relation.referrer
		field.schema = {
			&quot;oneOf&quot;: []
		}
		for(let item of relation.oneOf) {
			let relatedKlass = paths[item[&quot;$ref&quot;]]
			field.schema.oneOf.push(buildObjectField(relatedKlass, relation.referred, &quot;object&quot;))
			
			inverses[relatedKlass] = {}
			inverses[relatedKlass].type = &quot;object&quot;
			inverses[relatedKlass].key = relation.referred
			inverses[relatedKlass].schema = buildObjectField(relatedKlass, relation.referrer, &quot;object&quot;)
		}
	}

	return {field, inverses}
}

/**
 * @param {Object} relation - A single schema describing a relation
 * @param {String} klassName - The klass that this relation belongs to
 * @param {Object} paths - A javascript object that maps schema paths to klass names
 * @return {Object, Object} - buildOneToMany creates the fields required for a one to 
 * many relation. The first object is the field for the klass initiating the relation.
 * The second object contains an inverse field for each other klass involved in the relation.
 */
function buildOneToMany(relation, klassName, paths) {
	validateRelationSchema(relation, paths)

	let field = {}
	let inverses = {}
	if(relation.hasOwnProperty(&quot;$ref&quot;)) {
		let relatedKlass = paths[relation[&quot;$ref&quot;]]
		field.schema = buildArrayField(relation.referred, {&quot;type&quot;: &quot;object&quot;, &quot;klass&quot;: relatedKlass}, &quot;object&quot;)
		field.key = relation.referrer
		field.type = &quot;array&quot;

		inverses[relatedKlass] = {}
		inverses[relatedKlass].schema = buildObjectField(klassName, relation.referrer, &quot;array&quot;)
		inverses[relatedKlass].type = &quot;object&quot;
		inverses[relatedKlass].key = relation.referred
	} else if (relation.hasOwnProperty(&quot;oneOf&quot;)) {
		field = {}
		field.type=&quot;array&quot;
		field.key = relation.referrer

		let items = {
			&quot;oneOf&quot;: []
		}

		for(let item of relation.oneOf) {
			let relatedKlass = paths[item[&quot;$ref&quot;]]
			items.oneOf.push({&quot;type&quot;: &quot;object&quot;, &quot;klass&quot;: relatedKlass})
			
			inverses[relatedKlass] = {}
			inverses[relatedKlass].type = &quot;object&quot;
			inverses[relatedKlass].key = relation.referred
			inverses[relatedKlass].schema = buildObjectField(klassName, relation.referrer, &quot;array&quot;)
		}

		field.schema = buildArrayField(relation.referred, items, &quot;object&quot;)
	}

	return {field, inverses}
}

/**
 * @param {Object} relation - A single schema describing a relation
 * @param {String} klassName - The klass that this relation belongs to
 * @param {Object} paths - A javascript object that maps schema paths to klass names
 * @return {Object, Object} - buildManyToMany creates the fields required for a many to 
 * many relation. The first object is the field for the klass initiating the relation.
 * The second object contains an inverse field for each other klass involved in the relation.
 */
function buildManyToMany(relation, klassName, paths) {
	validateRelationSchema(relation, paths)

	let field = {}
	let inverses = {}
	if(relation.hasOwnProperty(&quot;$ref&quot;)) {
		let relatedKlass = paths[relation[&quot;$ref&quot;]]
		field.schema = buildArrayField(relation.referred, {type: &quot;object&quot;, klass: relatedKlass}, &quot;array&quot;)
		field.key = relation.referrer
		field.type = &quot;array&quot;

		inverses[relatedKlass] = {}
		inverses[relatedKlass].schema = buildArrayField(relation.referrer, {type: &quot;object&quot;, klass: klassName}, &quot;array&quot;)
		inverses[relatedKlass].type = &quot;array&quot;
		inverses[relatedKlass].key = relation.referred
	} else if (relation.hasOwnProperty(&quot;oneOf&quot;)) {
		field = {}
		field.type=&quot;array&quot;
		field.key = relation.referrer

		let items = {
			&quot;oneOf&quot;: []
		}

		for(let item of relation.oneOf) {
			let relatedKlass = paths[item[&quot;$ref&quot;]]
			items.oneOf.push({&quot;type&quot;: &quot;object&quot;, &quot;klass&quot;: relatedKlass})
			
			inverses[relatedKlass] = {}
			inverses[relatedKlass].type = &quot;array&quot;
			inverses[relatedKlass].key = relation.referred
			inverses[relatedKlass].schema = buildArrayField(relation.referrer, {type: &quot;object&quot;, &quot;klass&quot;: klassName}, &quot;array&quot;)
		}

		field.schema = buildArrayField(relation.referred, items, &quot;array&quot;)
	}

	return {field, inverses}
}

/**
 * @param {String} inverseKey - The property key used to access the inverse field in this fields value
 * @param {Array} items - An object containing the schema for the item that this array field holds.
 * @param {String} inverseType - A string, either &quot;object&quot; or &quot;array&quot;. Used to identify the type of the inverse field
 * @return {Object} A regular javascript object that describes the schema for the created field
 */
function buildArrayField(inverseKey, items, inverseType) {
	return {
		&quot;type&quot;: &quot;array&quot;,
		&quot;items&quot;: items,
		&quot;inverseKey&quot;: inverseKey,
		&quot;inverseType&quot;: inverseType

	}
}

/**
 * @param {String} klass - A string representing the klass that this object field must hold
 * @param {String} inverseKey - The property key used to access the inverse field in this fields value
 * @param {String} inverseType - A string, either &quot;object&quot; or &quot;array&quot;. Used to identify the type of the inverse field
 * @return {Object} A regular javascript object that describes the schema for the created field
 */
function buildObjectField(klass, inverseKey, inverseType) {
	return {
		&quot;type&quot;: &quot;object&quot;,
		&quot;klass&quot;: klass,
		&quot;inverseKey&quot;: inverseKey,
		&quot;inverseType&quot;: inverseType
	}
}

/**
 * @param {Object} property - A JSON schema describing a single property
 * @param {String} type - The type of the property
 * @param {Object} paths - An object that maps schema paths to the corresponding klass name
 * @return {Object} A parsed property
 * @throws {TypeError} - If the schema contains an invalid keyword then an error is thrown
 */
function parseProperty(property, type, paths) {
	/* Shallow copy the given property to a new object so we don&apos;t modify the existing schema */
	let newProp = { ...property }

	switch(type) {
		case &quot;object&quot;: {
			/* An object must have a reference */
			if(newProp.hasOwnProperty(&quot;$ref&quot;)) {
				/* Replace the &apos;$ref&apos; keyword by a klass */
				newProp[&quot;klass&quot;] = paths[newProp[&quot;$ref&quot;]]
				if(newProp.klass == undefined) {
				}
				delete newProp[&quot;$ref&quot;]
				
			} else {
				throw new TypeError(&quot;A property of type &apos;object&apos; must have a &apos;$ref&apos; keyword that references the definition describing the object&quot;)
			}
			break
		}
		case &quot;array&quot;: {
			/* An array must define items */
			if(newProp.hasOwnProperty(&quot;items&quot;)) {
				if(newProp.items instanceof Array) {
					/* Parse each item in the array */
					newProp.items = parseArray(newProp.items, paths)
				} else {
					/* Items is a single property so we parse the property */
					let type = getType(newProp.items)
					newProp.items = parseProperty(newProp.items, type, paths)
				}
			} else {
				throw new TypeError(&quot;An array must define the type of its contained items in an &apos;items&apos; keyword&quot;)
			}
			break
		}
		case &quot;oneOf&quot;: {
			/* oneOf must be an array of types */
			if(newProp.oneOf instanceof Array) {
				/* Parse each item in the array */
				newProp.oneOf = parseArray(newProp.oneOf, paths)
			} else {
				throw new TypeError(&quot;The oneOf keyword must be an array of types&quot;)
			}
			break
		}
	}
	return newProp
}

/**
 * @param {Array} array - An array of JSON schema properties
 * @param {Object} paths - An object that maps schema paths to the corresponding klass name
 * @return {Array} An array containing the parsed properties
 */
function parseArray(array, paths) {
	let newArr = []
	for(let item of array) {
		/* For each item: parse the item and add it to the new Array */
		let type = getType(item)
		newArr.push(parseProperty(item, type, paths))
	}
	return newArr
}

/**
 * @param {Object} property - A JSON schema describing a single property
 * @return {String} The type of the given property
 */
function getType(property) {
	if(property.hasOwnProperty(&quot;enum&quot;)) {
		return &quot;enum&quot;
	}

	if(property.hasOwnProperty(&quot;oneOf&quot;)) {
		return &quot;oneOf&quot;
	}

	if(property.hasOwnProperty(&quot;type&quot;)) {
		return property.type
	}
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
