<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">framework/dataManager/fields/MFieldSingle.js | ManagedDataJS</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="An implementation of Managed Data in Javascript using ES6 proxies"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ManagedDataJS"><meta property="twitter:description" content="An implementation of Managed Data in Javascript using ES6 proxies"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/rvanbuijtenen/ManagedDataJS.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#datamanager">dataManager</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/DataManager.js~DataManager.html">DataManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/MObject.js~MObject.html">MObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/MObject.js~MObjectHandler.html">MObjectHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/Schema.js~KlassSchema.html">KlassSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/Schema.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSchema">parseSchema</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#datamanager-fields">dataManager/fields</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~ArrayHandler.html">ArrayHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~ArrayMField.html">ArrayMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~EnumMField.html">EnumMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldMulti.js~OneOfMField.html">OneOfMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~BooleanMField.html">BooleanMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~IntegerMField.html">IntegerMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~MField.html">MField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~MObjectMField.html">MObjectMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~NumberMField.html">NumberMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/framework/dataManager/fields/MFieldSingle.js~StringMField.html">StringMField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-MFieldFactory">MFieldFactory</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#mixins">mixins</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Locking">Locking</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Logging">Logging</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Persistence">Persistence</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">framework/dataManager/fields/MFieldSingle.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {MObject} from &quot;../MObject&quot;

/**
 * The basic MField class privides the API for data managers that
 * want to use the MFields values. By default we can invoke:
 *		
 * getValue		returns the internal value of the MField.
 * setValue		used to set the internal value of the MField.
 * getType			returns the type of the value stored in the MField.4
 * toString		returns a string representing this fields value
 *
 * Each class that extends MField must provide the validate(value) function
 * which returns true iff the given parameter matches the schema for this MField.
 */
export class MField {
	/**
	 * @param {String} type - A string representing the type of this MField
	 * @param {Object} schema - A JSON schema that describes this fields value
	 * @param {*} value - The value that should be used to initialize this MField
	 */
	constructor(type, schema, value) {
		/**
		 * String representing the type of the MField&apos;s value
		 * @type {String}
		 */
		this.type = type

		/**
		 * The schema describing this value
		 * @type {Schema}
		 */
		this.schema = schema

		/**
		 * The initial value for this MField
		 * @type {*}
		 */
		this.value = value
	}

	/**
	 * setValue takes a value as argument and attempts to validate this value. If it was valid we set 
	 * this.value to the value, and otherwise we throw the error returned by the validate method
	 * 
	 * @param {*} value - The value that should be set in this MField
	 */
	setValue(value) {
		let {valid, error} = this.validate(value)
		if(valid == false) {
			throw error
		} else {
			this.value = value
		}
	}

	/**
	 * @return {*} This MFields value
	 */
	getValue() {
		return this.value
	}

	/**
	 * @return {String} A string representing this MFields type
	 */
	getType() {
		return this.type
	}

	/**
	 * @return String representing this MFields value
	 */
	toString() {
		return this.type
	}

	validate(value) {
		let valid = true
		let error

		if(value === undefined) {
			valid = false
			error = new TypeError(&quot;Cannot validate &apos;undefined&apos; in MField of type &quot;+this.type)
		}
		return {valid, error}
	}

	is(other) {
		if(other.getValue() === this.value) {
			return true
		} else {
			return false
		}
	}
}

/**
 * Number implementation of MField which checks the following constraints:
 * 		
 *		REQUIRED:
 * 			value 							===&gt;	typeof(value) == typeof(Number)
 *		OPTIONAL:
 *			minimum &amp;&amp; exclusiveMinimum 	===&gt; 	value &gt; minimum
 *			minimum 						===&gt;	value &gt;= minimum
 *			maximum &amp;&amp; exclusiveMaximum		===&gt;	value &lt; maximum
 *			maximum 						===&gt;	value &lt;= maximum
 *			multipleOf						===&gt;	value%multipleOf == 0
 *
 *
 */
export class NumberMField extends MField {
	/**
	 * @param {Object} schema - A JSON schema that describes this MFields value
	 */ 
	constructor(schema) {
		if(schema.hasOwnProperty(&quot;minimum&quot;)) {
			super(&quot;number&quot;, schema, schema.minimum)
		} else {
			super(&quot;number&quot;, schema, 0)
		}
	}

	/**
	 * @param {*} value - The value that should be validated
	 *
	 * @return {Boolean, Error} Validate returns a boolean indicating whether the field is valid. If it is invalid an error is also returned
	 */ 
	validate(value) {
		let {valid, error} = super.validate(value)

		if(valid == false) {
			return {valid, error}
		}

		if(typeof(value) == &quot;number&quot;) {
			if( this.schema.hasOwnProperty(&quot;exclusiveMinimum&quot;) &amp;&amp; this.schema.hasOwnProperty(&quot;minimum&quot;) &amp;&amp; value &lt;= this.schema.minimum) {
				error = new TypeError(&quot;Value assigned to &quot;+this.type+&quot;MField must be greater than &quot;+this.schema.minimum)
				valid = false
				return {valid, error}
			} else if(this.schema.hasOwnProperty(&quot;minimum&quot;) &amp;&amp; value &lt; this.schema.minimum) {
				error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be greater than or equal to &quot;+this.schema.minimum)
				valid = false
				return {valid, error}
			}

			if(this.schema.hasOwnProperty(&quot;exclusiveMaximum&quot;) &amp;&amp; this.schema.hasOwnProperty(&quot;maximum&quot;) &amp;&amp; value &gt;= this.schema.maximum) {
				error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be less than &quot;+this.schema.maximum)
				valid = false
				return {valid, error}
			} else if (this.schema.hasOwnProperty(&quot;maximum&quot;) &amp;&amp; value &gt; this.schema.maximum) {
				error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be less than or equal to &quot;+this.schema.maximum)
				valid = false
				return {valid, error}
			}

			if(this.schema.hasOwnProperty(&quot;multipleOf&quot;) &amp;&amp; value%this.schema.multipleOf != 0) {
				error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be a multiple of &quot; + this.schema.multipleOf)
				valid = false
				return {valid, error}
			}


			valid = true
		} else {
			error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be of type &quot;+this.schema.type)
		}
		return {valid, error}
	}
}


/**
 * Integer implementation of MField which checks the following constraints:
 *
 *		REQUIRED:
 *			value 	===&gt;	value%1 == 0
 */
export class IntegerMField extends NumberMField {
	/**
	 * @param {Object} schema - A JSON schema that describes this MFields value
	 */ 
	constructor(schema) {
		super(schema)
		/**
		 * Override NumberMFields type
		 * @type {String}
		 */
		this.type = &quot;integer&quot;
	}

	/**
	 * @param {*} value - The value that should be validated
	 *
	 * @return {Boolean, Error} Validate returns a boolean indicating whether the field is valid. If it is invalid an error is also returned
	 */
	validate(value) {
		let {valid, error} = super.validate(value)
		if(valid == true) {
			if(value%1 == 0) {
				valid = true
			} else {
				valid = false
				error = new TypeError(&quot;value assigned to &quot;+this.type+&quot;MField must be of type &quot;+this.schema.type)
			}
		}
		return {valid, error}
	}
}


 /**
 *	String implementation of MField which checks the following constraints:
 *
 *		REQUIRED:
 *			value 		===&gt;	typeof(value) == typeof(String)
 *		OPTIONAL:
 *			minLength	===&gt;	value.length &gt;= minLength
 *			maxLength	===&gt;	value.length &lt;= maxLength
 *			pattern		===&gt;	value matches pattern
 *			format		===&gt;	value is one of:
 * 
 * 									date-time
 * 									email
 * 									hostname
 * 									ipv4
 * 									ipv6
 * 									uri
 */
export class StringMField extends MField {
	/**
	 * @param {Object} schema - A JSON schema that describes this MFields value
	 */ 
	constructor(schema) {
		super(&quot;string&quot;, schema, &quot;&quot;)
	}


	/**
	 * @param {*} value - The value that should be validated
	 *
	 * @return {Boolean, Error} Validate returns a boolean indicating whether the field is valid. If it is invalid an error is also returned
	 */
	validate(value) {
		let {valid, error} = super.validate(value)

		if(!typeof(value) === &quot;string&quot;) {
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField must be a String&quot;)
			return {valid, error}
		}

		if(this.schema.hasOwnProperty(&quot;minLength&quot;) &amp;&amp; value.length &lt; this.schema.minLength) {
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField is shorter than the minimum length of &quot;+this.schema.minLength)
			return {valid, error}
		}

		if(this.schema.hasOwnProperty(&quot;maxLength&quot;) &amp;&amp; value.length &gt; this.schema.maxLength + exclMax) {
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField is longer than the maximum length of &quot;+this.schema.maxLength)
			return {valid, error}
		}

		if(this.schema.hasOwnProperty(&quot;pattern&quot;) ** value.match(this.schema.pattern) == null) {
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the pattern &quot;+this.schema.pattern);
			return {valid, error}
		}

		if(this.schema.hasOwnProperty(&quot;format&quot;)) {
			if(this.schema.format == &quot;date-time&quot;) {
				if(Date.parse(value) == NaN) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the date-time format&quot;)
					return {valid, error}
				}
			} else if (this.schema.format == &quot;email&quot;) {
				if(/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(value) == false) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the email format&quot;)
					return {valid, error}
				}
			} else if (this.schema.format == &quot;hostname&quot;) {
				if(/^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/.test(value) == false) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the hostname format&quot;)
					return {valid, error}
				}
			} else if (this.schema.format == &quot;ipv4&quot;) {
				if(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/.test(value) == false) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the ipv4 format&quot;)
					return {valid, error}
				}
			} else if (this.schema.format == &quot;ipv6&quot;) {
				if(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/.test(value) == false) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the ipv6 format&quot;)
					return {valid, error}
				}
			} else if (this.schema.format == &quot;uri&quot;) {
				if(/^([a-z][a-z0-9+.-]*):(?:\/\/((?:(?=((?:[a-z0-9-._~!$&amp;&apos;()*+,;=:]|%[0-9A-F]{2})*))(\3)@)?(?=(\[[0-9A-F:.]{2,}\]|(?:[a-z0-9-._~!$&amp;&apos;()*+,;=]|%[0-9A-F]{2})*))\5(?::(?=(\d*))\6)?)(\/(?=((?:[a-z0-9-._~!$&amp;&apos;()*+,;=:@\/]|%[0-9A-F]{2})*))\8)?|(\/?(?!\/)(?=((?:[a-z0-9-._~!$&amp;&apos;()*+,;=:@\/]|%[0-9A-F]{2})*))\10)?)(?:\?(?=((?:[a-z0-9-._~!$&amp;&apos;()*+,;=:@\/?]|%[0-9A-F]{2})*))\11)?(?:#(?=((?:[a-z0-9-._~!$&amp;&apos;()*+,;=:@\/?]|%[0-9A-F]{2})*))\12)?$/.test(value) == false) {
					error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField does not match the uri format&quot;)
					return {valid, error}
				}
			}
		}

		valid = true;
		return {valid, error}
	}
}

/**
 * Integer implementation of MField which checks the following constraints:
 *
 *		REQUIRED:
 *			value 	===&gt;	typeof(value) == typeof(Boolean)
 */
export class BooleanMField extends MField {
	/**
	 * @param {Object} schema - A JSON schema that describes this MFields value
	 */ 
	constructor(schema) {
		super(&quot;boolean&quot;, schema, false)
	}

	/**
	 * @param {*} value - The value that should be validated
	 *
	 * @return {Boolean, Error} Validate returns a boolean indicating whether the field is valid. If it is invalid an error is also returned
	 */
	validate(value) {
		let valid, error = super.validate(value)
		if(value === false || value === true) {
			return {valid, error}
		} else {
			valid = false;
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField must be a Boolean&quot;)
			return {valid, error}
		}
	}
}

/**
 * MObject implementation of MField which checks the following constraints:
 *
 *		REQUIRED:
 *			value 	 			===&gt;	value instanceof MObject &amp;&amp; value.klass == schema.klass
 *		OPTIONAL:
 *			inverse		 		===&gt;	(value[inverse] == this || value[inverse].includes(this))
 */
export class MObjectMField extends MField {
	/**
	 * @param {Object} schema - A JSON schema that describes this MFields value
	 * @param {MObject} superKlass - The MObject that this field belongs to
	 */ 	
	constructor(schema, superKlass) {
		super(&quot;object&quot;, schema, null)

		/**
		 * The MObject that this OneOfMField belongs to
		 * @type {MObject}
		 */
		this.superKlass = superKlass
	}

	addRelatedObject(other) {
		this.setValue(other)
	}

	removeRelatedObject(other) {
		if(this.value == other) {
			this.value = null
		}
	}

	/**
	 * @param {*} value - The value that should be validated
	 *
	 * @return {Boolean, Error} Validate returns a boolean indicating whether the field is valid. If it is invalid an error is also returned
	 */
	validate(value) {
		let {valid, error} = super.validate(value)
		if(value == null) {
			return {valid, error}
		}

		/* Validate that the given value is an MObject and that it is of the right Klass */
		if(!(value instanceof MObject &amp;&amp; value.getKlass() == this.schema.klass)) {
			console.log(value, value instanceof MObject, value.getKlass() == this.schema.klass, this.schema)
			error = new TypeError(&quot;value assigned to &quot;+this.schema.type+&quot;MField must be managed data&quot;)
			valid = false;
			return {valid, error}
		}

		valid = true
		return {valid, error}
	}

	setValue(value) {
		super.setValue(value)

		if(value == null) {
			return
		}
		if(this.schema.hasOwnProperty(&quot;inverseKey&quot;)) {
			if(this.schema.inverseType == &quot;object&quot;) {
				if(this.value[this.schema.inverseKey] != this.superKlass)
				value[this.schema.inverseKey] = this.superKlass
			} else {
				if(!(this.value[this.schema.inverseKey].includes(this.superKlass))) {
					this.value[this.schema.inverseKey].push(this.superKlass)
				}
			}
		}
	}
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
